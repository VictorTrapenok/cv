<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="rss.xsl"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>I'm searching new remote job Blog</title>
        <link>https://viktor-t.com/blog</link>
        <description>I'm searching new remote job Blog</description>
        <lastBuildDate>Wed, 16 Oct 2024 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[12 Years in Open-Source]]></title>
            <link>https://viktor-t.com/blog/12-Years-in-Open-Source</link>
            <guid>https://viktor-t.com/blog/12-Years-in-Open-Source</guid>
            <pubDate>Wed, 16 Oct 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[12 Years in Open-Source]]></description>
            <content:encoded><![CDATA[<p><img decoding="async" loading="lazy" alt="12 Years in Open-Source" src="https://viktor-t.com/assets/images/logo-e202317c4e8df00ac054be00e6d05c3e.webp" width="1280" height="720" class="img_ev3q"></p>
<p><em>(To summarize: approximately $8,000)</em></p>
<p>At the beginning of 2012, I started working on <a href="https://github.com/CppComet/comet-server" target="_blank" rel="noopener noreferrer">my first open-source project</a>. It was a comet server written in C++.</p>
<p>The idea was simple: create a comet server with an API and a SaaS subscription service. The closest analogy is pusher.com.</p>
<p>I completed the project and even added more features than I originally planned. In synthetic tests, my server handled up to <strong>64,000 simultaneous connections</strong>. I invested a significant amount of my time — around <strong>2,000 hours of work</strong>, by my estimate.</p>
<p>The project attracted more than <strong>20,000 registrations</strong>, and about <strong>1,000 websites</strong> actively used my API. However, most of them stayed on the free tier. At its peak, the total number of concurrent WebSocket connections reached <strong>8,000</strong>.</p>
<p>My largest client was the Russian federal TV channel <strong>OTR</strong>, and I even signed a contract with them for technical support.</p>
<p>But financially, the project was almost a complete failure. I wasn’t able to effectively market my solution. Over nearly <strong>12 years</strong>, the total revenue from subscriptions amounted to about <strong>$8,000</strong> from various users — barely enough to cover hosting costs.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-reasons">The Reasons:<a href="https://viktor-t.com/blog/12-Years-in-Open-Source#the-reasons" class="hash-link" aria-label="Direct link to The Reasons:" title="Direct link to The Reasons:">​</a></h2>
<ul>
<li>I did not have experience in marketing (I’ve since learned a lot, but it took time).</li>
<li>The process from start to paid subscription was too long.</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="but-what-else-did-i-gain">But What Else Did I Gain?<a href="https://viktor-t.com/blog/12-Years-in-Open-Source#but-what-else-did-i-gain" class="hash-link" aria-label="Direct link to But What Else Did I Gain?" title="Direct link to But What Else Did I Gain?">​</a></h2>
<ul>
<li>I used this project as a topic for my <strong>diploma thesis</strong> at the institute.</li>
<li>I received <strong>dozens of freelance jobs</strong> for developing chats and video chats.</li>
<li>Over the years, I talked about this project in <strong>every job interview</strong>, as much as I talked about my other work experience.</li>
<li>I’m pretty sure this project helped me get a job at <strong>cube.dev</strong>, where I learned a lot.</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-indirect-benefits">The Indirect Benefits<a href="https://viktor-t.com/blog/12-Years-in-Open-Source#the-indirect-benefits" class="hash-link" aria-label="Direct link to The Indirect Benefits" title="Direct link to The Indirect Benefits">​</a></h2>
<p>It’s hard to quantify the indirect benefits. But without this project in my portfolio, how much harder would it have been to find work? How much less would I have been paid in my positions?</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="in-conclusion">In Conclusion:<a href="https://viktor-t.com/blog/12-Years-in-Open-Source#in-conclusion" class="hash-link" aria-label="Direct link to In Conclusion:" title="Direct link to In Conclusion:">​</a></h2>
<p>For anyone starting their own project, here’s my advice:</p>
<p><strong>Start!</strong> It’s an amazing experience. But if, like me, you hope to earn from it, <strong>think about marketing and monetization from the start.</strong></p>]]></content:encoded>
            <category>Open-Source</category>
            <category>Startup</category>
        </item>
        <item>
            <title><![CDATA[Reducing CI/CD infrastructure costs]]></title>
            <link>https://viktor-t.com/blog/karpenter-for-gitlabrunner</link>
            <guid>https://viktor-t.com/blog/karpenter-for-gitlabrunner</guid>
            <pubDate>Tue, 15 Oct 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[Reducing CI/CD infrastructure costs]]></description>
            <content:encoded><![CDATA[<p><img decoding="async" loading="lazy" alt="Reducing CI/CD infrastructure costs" src="https://viktor-t.com/assets/images/logo-e82f6d71cb1b6a832578ceb2d0f0e3b0.webp" width="721" height="406" class="img_ev3q"></p>
<p>I want to share how we at Nanoheal reduced our infrastructure costs by using GitLab runners in Kubernetes with Karpenter on spot instances.</p>
<p>At Nanoheal, we have a high level of developer activity, and CI/CD pipelines runs a critical role in our DevOps practices for continuous delivery.</p>
<p>Previously, we ran three powerful EC2 virtual machines in our AWS account, dedicated to hosting GitLab runners. However, since our team worked within the same time zone, these machines sat idle almost 16 hours per day, as most work was done during business hours. During the remaining 8 hours, the servers were often overloaded due to peak demand.</p>
<h1>The Solution</h1>
<p>I migrated GitLab runners to Kubernetes. We already had a Kubernetes cluster running in AWS, so I configured Karpenter to handle autoscaling within the cluster.</p>
<p>Karpenter uses taints and node affinity rules to determine on which nodes specific pods should run.</p>
<p>The configuration is set up so that Karpenter creates a node when a GitLab runner starts a pipeline. Then pipeline runs on a spot instance, specifically dedicated for CI/CD tasks. Our pipelines consume a significant amount of resources and can negatively impact other services if they share the same node in the cluster.</p>
<p>Once the pipeline completes, the node remains empty, thanks to the properly configured taints, which prevent other pods from being scheduled on it. After 30 minutes of inactivity, Karpenter automatically removes the node.</p>
<h1>The Result</h1>
<p>By migrating CI/CD pipelines to our Kubernetes cluster, we eliminated the need for three always-on virtual machines. Instead, we now run 1–2 spot nodes in the cluster, running ~60 hours per week, drastically cutting down our infrastructure costs.</p>
<p>You can get <a href="https://github.com/VictorTrapenok/karpenter-for-gitlabrunner" target="_blank" rel="noopener noreferrer">configuration files in my github</a></p>
<ul>
<li>Helm chart for gitlab runner: <a href="https://gitlab.com/gitlab-org/charts/gitlab-runner" target="_blank" rel="noopener noreferrer">gitlab-runner</a></li>
<li>karpenter autoscaller: <a href="https://karpenter.sh/" target="_blank" rel="noopener noreferrer">karpenter</a></li>
<li>karpenter configuration <a href="https://github.com/VictorTrapenok/karpenter-for-gitlabrunner/blob/main/karpenter-coniguration.yaml" target="_blank" rel="noopener noreferrer">karpenter-coniguration.yaml</a></li>
</ul>
<h1>Any help?</h1>
<p>Please ping me in <a href="https://www.linkedin.com/in/victor-trapenok/" target="_blank" rel="noopener noreferrer">linkedin</a> if you need any help. I am open to work.</p>]]></content:encoded>
            <category>Karpenter</category>
            <category>GitLab</category>
            <category>Kubernetes</category>
        </item>
        <item>
            <title><![CDATA[Integration Testing for Telegram Bots]]></title>
            <link>https://viktor-t.com/blog/Testing-for-Telegram-Bots</link>
            <guid>https://viktor-t.com/blog/Testing-for-Telegram-Bots</guid>
            <pubDate>Sat, 20 Apr 2019 00:00:00 GMT</pubDate>
            <description><![CDATA[This is the text of my speech at the FAR EAST Devops DAYS conference]]></description>
            <content:encoded><![CDATA[<p>This is the text of my speech at the <a href="https://www.youtube.com/watch?v=QO2FQZCoggA&amp;t=105s" target="_blank" rel="noopener noreferrer">FAR EAST Devops DAYS conference</a>
about my experience with <strong>integration testing for Telegram bots</strong>. Specifically, I’ll discuss the challenges and solutions I encountered when testing a Telegram bot that I inherited as part of a project.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/QO2FQZCoggA?si=6DjHPXJct4Yttc6c&amp;start=73" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin"></iframe>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-project-context">The Project Context<a href="https://viktor-t.com/blog/Testing-for-Telegram-Bots#the-project-context" class="hash-link" aria-label="Direct link to The Project Context" title="Direct link to The Project Context">​</a></h2>
<p>The bot was originally written in PHP using the <strong>MadelineProto</strong> library. For those unfamiliar with this library, it's quite versatile. It not only allows you to create traditional Telegram bots, but it also supports automating actions on behalf of user accounts, which opens up possibilities that regular bots don't offer, such as making audio calls.</p>
<p>When I joined the project, the bot already had a significant amount of code. However, <strong>there were no tests</strong> whatsoever. As you can imagine, this was a major productivity bottleneck since I had to manually test the bot’s functionality at the end of each workday. Writing tests became my priority to speed up development.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-challenge-of-finding-existing-libraries">The Challenge of Finding Existing Libraries<a href="https://viktor-t.com/blog/Testing-for-Telegram-Bots#the-challenge-of-finding-existing-libraries" class="hash-link" aria-label="Direct link to The Challenge of Finding Existing Libraries" title="Direct link to The Challenge of Finding Existing Libraries">​</a></h2>
<p>My initial approach was to search for existing libraries that could facilitate the testing process. However, after some research, I found that most of the libraries available were written in <strong>Node.js</strong>, which wasn't ideal for my PHP-based bot. Integrating them would have taken considerable time and effort, and they wouldn’t have allowed me to test the bot directly through Telegram’s API.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="my-solution-testing-via-telegram-web">My Solution: Testing via Telegram Web<a href="https://viktor-t.com/blog/Testing-for-Telegram-Bots#my-solution-testing-via-telegram-web" class="hash-link" aria-label="Direct link to My Solution: Testing via Telegram Web" title="Direct link to My Solution: Testing via Telegram Web">​</a></h2>
<p>Given the limitations, I decided on a simpler approach: <strong>testing the bot through Telegram Web</strong>. By interacting with the bot via the web interface, I could simulate user actions like sending messages and clicking buttons. To achieve this, I wrote a small set of functions/scripts that automated these actions, which I’ll share with you later in this post.</p>
<p>This approach was quite effective. The script would send messages to the bot, click buttons, and perform other necessary tasks, saving me hours of manual testing.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="how-it-works">How It Works<a href="https://viktor-t.com/blog/Testing-for-Telegram-Bots#how-it-works" class="hash-link" aria-label="Direct link to How It Works" title="Direct link to How It Works">​</a></h2>
<p>Here’s a brief overview of how the testing script operates:</p>
<ol>
<li><strong>Open Telegram Web</strong>.</li>
<li><strong>Inject the testing script</strong> into the browser’s developer console.</li>
<li>The script then automates interactions with the bot, simulating a real user.</li>
</ol>
<p>You can run the test, and while it’s running, you can relax with a cup of tea or work on something else. Once the test is completed, you get the results — whether the bot passed or if there were any issues.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="limitations">Limitations<a href="https://viktor-t.com/blog/Testing-for-Telegram-Bots#limitations" class="hash-link" aria-label="Direct link to Limitations" title="Direct link to Limitations">​</a></h2>
<p>The main drawback of this approach is that it <strong>doesn’t provide a full testing cycle</strong>. Ideally, I would integrate this with <strong>Selenium</strong> to run tests automatically from a console or CI/CD pipeline, but so far, I’ve encountered issues with authenticating in Telegram via Selenium.</p>
<p>Another limitation is that Telegram has multiple platforms (iOS, Android, web), and they don’t always behave the same way. For example, the layout of messages may differ across platforms, which makes it hard to test the user experience consistently.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="key-benefits">Key Benefits<a href="https://viktor-t.com/blog/Testing-for-Telegram-Bots#key-benefits" class="hash-link" aria-label="Direct link to Key Benefits" title="Direct link to Key Benefits">​</a></h2>
<p>Despite its limitations, this was the <strong>quickest and easiest</strong> way to introduce some form of test automation into the project, which initially had none. It significantly improved our development speed and confidence in the bot’s functionality.</p>
<p>Here’s a simple example of how you can test a scenario using the script:</p>
<ol>
<li><strong>Send a message</strong> to the bot.</li>
<li><strong>Check the bot’s response</strong> for expected text.</li>
<li><strong>Click a button</strong> in the bot’s response.</li>
<li><strong>Wait for the next message</strong> and verify it.</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="future-plans">Future Plans<a href="https://viktor-t.com/blog/Testing-for-Telegram-Bots#future-plans" class="hash-link" aria-label="Direct link to Future Plans" title="Direct link to Future Plans">​</a></h2>
<p>One of my future goals is to integrate <strong>Selenium</strong> more effectively for even better automation. However, for now, this solution works, and it’s saving a lot of manual effort.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusion">Conclusion<a href="https://viktor-t.com/blog/Testing-for-Telegram-Bots#conclusion" class="hash-link" aria-label="Direct link to Conclusion" title="Direct link to Conclusion">​</a></h2>
<p>To summarize, if you’re working on a Telegram bot and need a quick way to set up integration tests, testing through <strong>Telegram Web</strong> is a simple and effective solution. Although it doesn’t offer full coverage and automation, it’s a great starting point when no tests are in place.</p>
<hr>
<p>Feel free to ask any questions in the comments or reach out to me directly. Thank you for reading!</p>]]></content:encoded>
            <category>Integration-Testing</category>
            <category>E2E</category>
            <category>Telegram</category>
            <category>Testing</category>
        </item>
    </channel>
</rss>